/*
 * (C) Copyright 2015
 * Stefano Babic, DENX Software Engineering, sbabic@denx.de.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */

/*
 * This is a simple example how to control swupdate
 * triggering for a new update, streaming ore or more images
 * and asking for the result.
 * This program is not thought to be used as it is, but as example
 * how to use the swupdateipc library.
 * A common use case is when swupdate is in double-copy option
 * and not in rescue, and the communication with the external world
 * is realized by a custom application. The new software image can be
 * also loaded by the main application and then streamed to swupdate
 * via the IPC protocol.
 *
 * The library performs an async update: the user initializes the
 * library with callbacks that are called for each phase of the update process.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <pthread.h>
#include "network_ipc.h"
#include <progress_ipc.h>

static void usage(void) {
	printf("swimage <image .swu to be installed>...\n");
}

char buf[256];
int fd;
int complete = 0;
int connfd;
struct progress_msg msg;
int curstep = 0;
char bar[10];
unsigned int filled_len;

/*
 * this is the callback to get a new chunk of the
 * image.
 * It is called by a thread generated by the library and
 * can block.
 */
static int readimage(char **p, int *size) {
	int ret;

	ret = read(fd, buf, sizeof(buf));

	*p = buf;

	*size = ret;

	return ret;
}

/*
 * This is called by the library to inform
 * about the current status of the upgrade
 */
static int printstatus(ipc_message *msg)
{
	/*printf("Status: %d message: %s\n",
		msg->data.status.current,
		msg->data.status.desc ? msg->data.status.desc : "");*/

	return 0;
}

/*
 * this is called at the end reporting the status
 * of the upgrade
 */
static int end(RECOVERY_STATUS status)
{
	printf("Swupdate %s\n",
		status == FAILURE ? "*failed* !" :
			"was successful !");

	complete = 1;

	return 0;
}

/*
 * Send file to main swupdate process
 */
static int send_file(const char* filename) {
	int rc;
	if ( (fd = open(filename, O_RDONLY)) < 0) {
		printf ("I cannot open %s\n", filename);
		return 1;
	}

	if( (connfd = progress_ipc_connect(1)) < 0) {
		printf ("I cannot open progress ipc\n");
		return 1;
	}

	rc = swupdate_async_start(readimage, printstatus,
				end);

	while(complete == 0) {
		progress_ipc_receive(&connfd, &msg);

		if (msg.infolen > 0)
			fprintf(stdout, "INFO: %s\n\n", msg.info);

		if ((msg.cur_step != curstep) && (curstep != 0))
			fprintf(stdout, "\n");

		filled_len = sizeof(bar) * msg.cur_percent / 100;
		if (filled_len > sizeof(bar))
			filled_len = sizeof(bar);

		memset(bar,'=', filled_len);
		memset(&bar[filled_len], '-', sizeof(bar) - filled_len);

		fprintf(stdout, "[%.10s] %3d%% %-20.20s\r",
			bar, msg.cur_percent, msg.cur_image);

		if(msg.status == SUCCESS) {
			fprintf(stdout, "\nSUCCESS !\n");
			complete = 1;
		} else if(msg.status == FAILURE) {
			fprintf(stdout, "\nFAILURE !\n");
			complete = 1;
		}
		fflush(stdout);

		curstep = msg.cur_step;
	}

	return 0;
}


int main(int argc, char *argv[]) {
	int c;

	/* parse command line options */
	while ((c = getopt(argc, argv, "h")) != EOF) {
		switch (c) {
		case 'h':
			usage();
			return 0;
		default:
			usage();
			return -1;
		}
	}
	argc -= optind;
	argv += optind;

	if (argc == 0 || (argc == 1 && strcmp(argv[0], "-") == 0)) {
		if (send_file(NULL)) exit(1);
	} else {
		for (int i = 0; i < argc; i++) {
			if (send_file(argv[i])) exit(1);
		}
	}

	exit(0);
}

